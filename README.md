# RISCV_SIMULATOR_PARALLEL
首先是时（流）间（水）线（帐)：
	7.1：开学+懵逼
	7.2：对串行的整个过程有了一个初步的了解+初步构思好了整体的实现
	7.3：对各个指令的含义以及立即数的含义以及移位操作有了一定的了解
	7.4：经过一天的debug之后成功实现了串行的版本
	7.5：出成绩的浮躁+构思并行版本的实现
	7.8：设计好了并行版本的实现方案+成功实现了并行的最初版本
	7.9：对JAL操作做了一点优化+试图实现forwarding失败
	7.10：疯狂debug forwarding操作成功+构思分支预测+debug到零点左右成功实现
	7.11：尝试了哈希等稍准确一些的分支预测方式，把分支预测的准确率提高了一点

然后是各个版本的实现：
V1.0：
	实现了串行的功能，每个指令顺次执行，并且对每一个指令都是执行完一个阶段再执行下一个阶段。
	采用了接近于课上讲的第二种方式的实现，不过并没有把37条指令全部封装成类，而是将四种核心指令格式即R, I, S, U四种类型各封装成一个类，每个类包括ID, EX, MEM, WB四个公有成员函数，在每个成员函数内部通过switch(opcode)以及func3等来决定具体的指令内容以及执行的操作。除此之外，每个类还包括opcode等code本身给出的信息以及EX阶段的结果result，这些均为公有数据成员。
	对于IF阶段，我将其单独封装成了一个函数。这个函数根据opcode的不同，创建相应的类的对象，并顺次执行余下的四个阶段。
	可能由于我的实现中面向对象的程度比较低，串行版本的运行速度是比较快的，OJ上的运行时间是3140 MS。

V2.0：
	实现了并行的功能。
	由于在上一个版本的实现中，从寄存器中调取值被我放在了EX阶段，在本次实现中我一开始是打算直接用向后平移了一个阶段的forwarding来解决data hazard的。但是助教告诉我这么写和实际过程有冲突，于是就把从寄存器中调取值放回了ID阶段，并乖乖地用等待闲置来解决data hazard以及control hazard。
	以及等待闲置的实现是借助lock掉寄存器以及PC实现的。
	并行版本的运行时间显著上升，达到了11296 MS。

V2.1：
	作出了一点小小的优化，将JAL指令之后的等待闲置改成了直接把PC的值修改为要跳转的地址，避免了JAL之后的等待过程。

V3.0：
	实现了forwarding的操作，即在发生data hazard的时候，不进行等待闲置，而是直接将修改后的值从EX或MEM传递到ID阶段。
	大概的实现方式就是增加了两个缓冲区，分别用来存放EX阶段得到的结果以及MEM阶段得到的结果，在寄存器lock时根据是EX导致的lock还是MEM导致的lock，分别从两个缓存区里调值。

V3.1：
	实现了分支预测的功能。
这一版分支预测的方式非常无脑，是分别存下来了所有指令跳转的次数之和和不跳转的次数之和，根据哪个大来确定跳转还是不跳转。
	当然，预测的成功率极其低下，最低的只有30%左右。
V3.2：
	改进了分支预测的方式。
	这一版采用的分支预测方式是根据code的后12位的不同，分别记录下每一条指令的跳转情况，再根据总和是跳转多还是不跳转多来决定是否进行跳转。
	预测的成功率有了一定的提高，情况大致如下(仅选取运行次数比较大的几个)：
1.	basicopt1：119647/155139  Accuracy ：77.1225%
2.	bulgarian: 60522/71493 Accuracy: 84.6544%
3.	hanoi: 12842/17457  Accuracy: 73.5636%
4.	magic: 51676/67869 Accuracy: 76.1408% 
5.	pi: 3.30684e+07/3.99564e+07 Accuracy:82.7611%
6.	qsort: 164114/200045 Accuracy: 82.0385% 
7.	queens: 56447/77116 Accuracy: 73.1975% 
8.	superloop: 379381/435027 Accuracy: 87.2086%
9.	tak: 45477/60639 Accuracy: 74.9963%
之后也尝试过利用其他的哈希方式进行预测，但是结果仅仅降低了预测率，于是就未采用。
感想：
1.	感谢助教的讲解，感谢同学的帮助，没有你们我肯定什么都写不出来。。。
2.	对于forwarding以及分支预测的添加，我全部是在最底层实现的，因此在debug的时候非常痛苦。以后吸取教训，绝对不要在最底层进行修改！！！
3.	感觉我现在面向对象编程的能力还很差，整个RISCV基本上全部是面向过程来实现的，还要多加训练啊。。。

